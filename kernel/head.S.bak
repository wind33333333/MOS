//===============================初始化代码和数据=================================================
.section    .init_text, "ax"
.globl _start
_start:
//==================bsp/ap核
    movl $0x1b,%ecx           //IA32_APIC_BASE=0x1b 寄存器
    rdmsr
    test $0x100,%eax          //測試bit8 1bsp 0ap
    jz kernel_stack_init


//////////////////////cpu_num=cpu数量
    mov        $1,%eax
    cpuid
    shr        $16,%ebx
    mov        %rbx,%rax
    movabs     %rax,cpu_num

//////////////////开辟多核栈空间
    movabs     cpu_num,%rax
    mov        $0x4000*3,%rax
    mul        %rbx
    mov        %rax,%rbx
    movabs     kernel_memend,%rax
    add        %rbx,%rax
    movabs     %rax,kernel_memend
    movabs     %rax,kernel_base_stack   //内核栈顶

////////////////开辟内存bitmap空间



/////////////////////开辟数GDT內存空間
    movabs     cpu_num,%rax
    shl        $4,%eax                   //tss描述符=cpu数量*16
    add        $0x50,%eax              //GDT长度=80字节预留+tss描述符长度
    add        $0xFFF,%eax
    and        $0xffff000,%eax          //+0x1000对齐4K
    mov        %rax,%rbx
    movabs     kernel_memend,%rax
    movabs     %rax,GDT_BASE            //初始化gdt指针
    add        %rbx,%rax
    movabs     %rax,kernel_memend
    dec        %rbx
    mov        %rbx,%rax
    movabs     %ax,GDT_LIMIT

//////////////////初始化GDT
    movabs     $GDT_BASE,%rdi
    mov        (%rdi),%rdi
    mov        $0x0000000000000000,%rax
    mov        %rax,(%rdi)                 /*0	NULL descriptor		       	00*/
    mov        $0x0020980000000000,%rax
    mov        %rax,8(%rdi)               /*1	KERNEL	Code	64-bit	Segment	08*/
    mov        $0x0000920000000000,%rax
    mov        %rax,16(%rdi)              /*2	KERNEL	Data	64-bit	Segment	10*/
    mov        $0x0020f80000000000,%rax
    mov        %rax,24(%rdi)              /*3	USER	Code	64-bit	Segment	18*/
    mov        $0x0000f20000000000,%rax
    mov        %rax,32(%rdi)              /*4	USER	Data	64-bit	Segment	20*/
    mov        $0x00cf9a000000ffff,%rax
    mov        %rax,40(%rdi)              /*5	KERNEL	Code	32-bit	Segment	28*/
    mov        $0x00cf92000000ffff,%rax
    mov        %rax,48(%rdi)              /*6	KERNEL	Data	32-bit	Segment	30*/


///////////开辟tss_table內存空間
    movabs     cpu_num,%rax
    mov        $104,%rbx
    mul        %rbx
    add        $0xFFF,%eax
    and        $0xffff000,%eax          //+0x1000对齐4K
    mov        %rax,%rbx
    movabs     kernel_memend,%rax
    movabs     %rax,TSS_BASE               //初始化TSS_table指针
    add        %rbx,%rax
    movabs     %rax,kernel_memend



///////////計算分頁目錄表需要的內存空間
    movabs     kernel_memend,%rax
    movabs     $VBASEADDR,%rbx
    sub        %rbx,%rax
    movabs     %rax,pml4e_pbase                  //pdpte起始物理地址

    mov        $0x0,%rdx
    mov        $4096,%rbx
    div        %rbx
    cmp        $0,%rdx
    jz         j1
    inc        %rax
j1:
    mov        $3,%rcx                          //1-3级页表數量
    mov        $512,%rbx
    mov        $0,%r8
pg_num:
    mov        $0x0,%rdx
    div        %rbx
    cmp        $0,%rdx
    jz         j2
    inc        %rax
j2:
    add        %rax,%r8
    loop       pg_num
    shl        $12,%r8                     //長度=1-3頁表數量*4k
    movabs     $kernel_memend,%rax
    add        %r8,(%rax)                  //內核結束長度

///////////////////計算內核pml4e、pdpte、pde、pte數量
    movabs     kernel_memend,%rax
    movabs     $VBASEADDR,%rbx
    sub        %rbx,%rax
    mov        $0x0,%rdx
    mov        $4096,%rbx
    div        %rbx
    cmp        $0,%rdx
    jz         j_pte
    inc        %rax
j_pte:
    movabs     %rax,pte_num                   //pte數量

    movabs     $pde_num,%rdi
    mov        $3,%rcx                        //1-3级页表數量
    mov        $512,%rbx
l1:
    mov        $0x0,%rdx
    div        %rbx
    cmp        $0,%rdx
    jz         j_pd
    inc        %rax
j_pd:
    mov        %rax,(%rdi)
    add        $8,%rdi
    loop       l1

/////////對稱映射四級分頁
    movabs     $PML4_VBASE,%rsi
    movabs     $pml4e_bak,%rdi
    movabs     pml4e_num,%rax
    mov        %rax,%rcx
    rep movsq                               //備份原pml4e

    movabs     $PML4_VBASE,%rdi
    movabs     pml4e_pbase,%rax
    mov        %rax,%rbx
    mov        $0xFFFFFFFFFFFFF000,%rax
    and        %rax,%rbx
    or         $0x7,%rbx
    movabs     pml4e_num,%rax
    mov        %rax,%rcx
pml4e_loop:
    mov        %rbx,(%rdi)
    add        $8,%rdi
    add        $4096,%rbx
    loop       pml4e_loop             //初始化pml4e
    mov        %rbx,%rax
    movabs      %rax,pml4e_pbase

    movabs     $PDPT_VBASE,%rdi
    movabs     pml4e_pbase,%rax
    mov        %rax,%rbx
    mov        $0xFFFFFFFFFFFFF000,%rax
    and        %rax,%rbx
    or         $0x7,%rbx
    movabs     pdpte_num,%rax
    mov        %rax,%rcx
pdpte_loop:
    mov        %rbx,(%rdi)
    add        $8,%rdi
    add        $4096,%rbx
    loop       pdpte_loop           //初始化pdpte
    mov        %rbx,%rax
    movabs      %rax,pml4e_pbase

    movabs     $PD_VBASE,%rdi
    movabs     pml4e_pbase,%rax
    mov        %rax,%rbx
    mov        $0xFFFFFFFFFFFFF000,%rax
    and        %rax,%rbx
    or         $0x3,%rbx
    movabs     pde_num,%rax
    mov        %rax,%rcx
pde_loop:
    mov        %rbx,(%rdi)
    add        $8,%rdi
    add        $4096,%rbx
    loop       pde_loop                 //初始化pde
    mov        %rbx,%rax
    movabs      %rax,pml4e_pbase

    movabs     $PT_VBASE,%rdi
    mov        $0x83,%rbx
    movabs     pte_num,%rax
    mov        %rax,%rcx
pte_loop:
    mov        %rbx,(%rdi)
    add        $8,%rdi
    add        $4096,%rbx
    loop       pte_loop                 //初始化pte
/*
    movabs     $PML4_VBASE,%rsi                 //移動到正式pml4e  0x0
    movabs     $__PML4T,%rdi
    movabs     pml4e_num,%rax
    mov        %rax,%rcx
    rep movsq
*/
    movabs     $PML4_VBASE,%rsi                 //移動到正式pml4e  0xFFFF800000000000
    movabs     $__PML4T+0x800,%rdi
    movabs     pml4e_num,%rax
    mov        %rax,%rcx
    rep movsq

    movabs     $PML4_VBASE,%rdi                 //還原pml4e
    movabs     $pml4e_bak,%rsi
    movabs     pml4e_num,%rax
    mov        %rax,%rcx
    rep movsq


//======= 初始化多核内核栈
kernel_stack_init:
    movl $0x1b,%ecx         //IA32_APIC_BASE=0x1b 寄存器
    rdmsr
    or $0xc00,%eax         //bit10启用x2apic ,bit11启用xapic
    wrmsr

    mov $0x802,%ecx
    rdmsr                   //获取APIC ID
    mov $0x4000*3,%rbx      //每个核心分配48K栈，默认rsp tss>rsp0 Tss>ist1
    mul %rbx
    movabs $kernel_base_stack,%rbx
    mov (%rbx),%rsp
    sub %rax,%rsp           //计算每个内核栈 栈顶=VBASESTACK-(APIC ID*48K)

//=======初始化TSS
    mov $0x802,%ecx
    rdmsr                   //获取APIC ID
    mov $104,%rbx
    mul %rbx
	movabs	$TSS_BASE,%rdi
	mov	(%rdi),%rdi
	add %rax,%rdi           //TSS基址

    xor %rax,%rax
    mov %rsp,%rbx

//======= 初始化TSS表
    sub    $0x4000,%rbx
    mov    %rbx,4(%rdi)     //rsp0
    mov    %rax,12(%rdi)    //rsp1
    mov    %rax,20(%rdi)    //rsp2
    sub    $0x4000,%rbx
    mov    %rbx,36(%rdi)    //ist1
    mov    %rax,44(%rdi)    //ist2
    mov    %rax,52(%rdi)    //ist3
    mov    %rax,60(%rdi)    //ist4
    mov    %rax,68(%rdi)    //ist5
    mov    %rax,76(%rdi)    //ist6
    mov    %rax,84(%rdi)    //ist7

//=======初始化TSS描述符
    mov     $0x802,%ecx
    rdmsr                           //获取APIC ID
    mov     %rdi,%rdx               //TSS基址
    shl     $4,%rax
    movabs	$GDT_BASE,%rdi
    mov     (%rdi),%rdi
    add     $0x50,%rdi
    add     %rax,%rdi               //GDT-TSS描述符基址 0x50+X

	xorq	%rax,	%rax
	xorq	%rbx,	%rbx
	movq	$0x89,	%rax
	shlq	$40,	%rax
	movl	%edx,	%ebx
	shrl	$24,	%ebx
	shlq	$56,	%rbx
	addq	%rbx,	%rax
	xorq	%rbx,	%rbx
	movl	%edx,	%ebx
	andl	$0xffffff,	%ebx
	shlq	$16,	%rbx
	addq	%rbx,	%rax
	addq	$103,	%rax
	movq   	%rax,	(%rdi)
	movq    %rdx,   %rbx
	shrq	$32,	%rbx
	movq	%rbx,	8(%rdi)

//=======	load GDTR
	lgdt	GDT_POINTER(%rip)

//=======	load	IDTR
	lidt	IDT_POINTER(%rip)

//=======	load	TR
    mov $0x802,%ecx
    rdmsr                            //获取APIC ID
    shl $4,%eax
    add	$0x50,	%ax                  //tss描述符起始0x40
    ltr	%ax
/*
    movabs $__PML4T,%rax
    movabs $VBASEADDR,%rbx
    sub %rbx,%rax
    mov %rax,%cr3
*/
    xchg %bx,%bx
	jmp	Kernel_init


.section    .init_data, "wa"
GDT_POINTER:
GDT_LIMIT:	    .word	0                    //bochs gdt限长大于fc06便会报错崩溃
GDT_BASE:   	.quad	0

IDT_POINTER:
IDT_LIMIT:	.word	IDT_END - IDT_Table - 1
IDT_BASE:	.quad	IDT_Table

TSS_BASE:       .quad	0

kernel_base_stack:	.quad	0

.globl kernel_memend
kernel_memend:   .quad   _end

.globl cpu_num
cpu_num:         .quad   0

pml4e_bak:   .fill    512,8,0

pml4e_pbase:  .quad   0
pte_num:     .quad   0
pde_num:     .quad   0
pdpte_num:   .quad   0
pml4e_num:   .quad   0

.equ    PML4_VBASE,0xFFFFFFFFFFFFF000     //pml4虛擬地址基址
.equ    PDPT_VBASE,0xFFFFFFFFFFE00000     //pdpt虛擬地址基址
.equ      PD_VBASE,0xFFFFFFFFC0000000     //pd虛擬地址基址
.equ      PT_VBASE,0xFFFFFF8000000000     //pt虛擬地址基址

.equ    VBASEADDR,0xffff800000000000      //内核虛擬地址基址


//========================================正式内核代码=================================================

.section    .text, "ax"
//=======	ignore_int
.globl ignore_int
ignore_int:
	cld
	pushq	%rax
	pushq	%rcx
	pushq	%rdx
	pushq	%rbx
	pushq	%rbp
	pushq	%rdi
	pushq	%rsi

	pushq	%r8
	pushq	%r9
	pushq	%r10
	pushq	%r11
	pushq	%r12
	pushq	%r13
	pushq	%r14
	pushq	%r15

	movq	%es,	%rax
	pushq	%rax
	movq	%ds,	%rax
	pushq	%rax

	movq	$0x10,	%rax
	movq	%rax,	%ds
	movq	%rax,	%es

	movabs	$int_msg,%rax			/* leaq get address */
	pushq	%rax
	movq	%rax,	%rdx
	movq	$0x00000000,	%rsi
	movq	$0x00ff0000,	%rdi
	movq	$0,	%rax
	callq	color_printk
	addq	$0x8,	%rsp

Loop:
	jmp	Loop

	popq	%rax
	movq	%rax,	%ds
	popq	%rax
	movq	%rax,	%es

	popq	%r15
	popq	%r14
	popq	%r13
	popq	%r12
	popq	%r11
	popq	%r10
	popq	%r9
	popq	%r8

	popq	%rsi
	popq	%rdi
	popq	%rbp
	popq	%rbx

//	in       $0x60,%al            //读取键盘状态

    mov     $0,%edx
    mov     $0,%eax
    mov     $0x80B,%ecx
    wrmsr                   //给local apic发送EOI

	popq	%rdx
	popq	%rcx
	popq	%rax
	iretq

int_msg:
	.asciz "Unknown interrupt or fault at RIP\n"


//========================================正式内核数据=================================================
	.section    .data, "wa"

    .globl IDT_Table1
    IDT_Table1:
    .globl IDT_Table
    IDT_Table:
    	.fill  0x1000-(.-IDT_Table),1,0
    IDT_END:

    .globl __PML4T
    __PML4T:
    	.quad	0
    	.fill	0xFF8-(. -__PML4T),1,0
    	.quad   (__PML4T- VBASEADDR)+0x7


    .globl	TSS64_Table
    TSS64_Table:
    	.fill  0x10000,1,0
    TSS64_END:
